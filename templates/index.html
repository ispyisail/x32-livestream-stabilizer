<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>X32 Livestream Stabilizer</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { max-width: 900px; margin: auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1, h2 { color: #0056b3; }
        .grid-container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        .status-box, .control-box { background-color: #e9ecef; padding: 15px; border-radius: 5px; }
        .status-item { margin-bottom: 5px; display: flex; justify-content: space-between; }
        .controls button { width: 100%; padding: 10px 15px; border: none; border-radius: 5px; cursor: pointer; font-size: 1em; margin-bottom: 10px; }
        .controls button.start { background-color: #28a745; color: white; }
        .controls button.stop { background-color: #dc3545; color: white; }
        .input-group { margin-bottom: 15px; }
        .input-group label { display: block; margin-bottom: 5px; font-weight: bold; }
        .input-group input[type="number"], .input-group input[type="text"] { width: calc(100% - 22px); padding: 8px; border-radius: 4px; border: 1px solid #ddd; }
        .input-group button { width: 100%; padding: 10px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 5px; }
        .message { margin-top: 15px; padding: 10px; border-radius: 5px; }
        .message.success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .message.error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }

        /* Level Meter Styling */
        .meter-container {
            width: 40px;
            height: 150px;
            background-color: #222;
            border-radius: 3px;
            overflow: hidden;
            position: relative;
            border: 1px solid #999;
        }
        .level-bar {
            width: 100%;
            background-color: green;
            position: absolute;
            bottom: 0;
            transition: height 0.15s linear, background-color 0.15s linear;
        }
        .level-meter-display {
            display: flex;
            align-items: flex-start;
            margin-bottom: 10px;
            gap: 4px;
        }
        .meter-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        .meter-column .meter-label {
            font-size: 0.75em;
            font-weight: bold;
            color: #555;
            text-align: center;
        }
        .level-values {
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding-left: 10px;
            gap: 8px;
        }
        .level-value {
            font-size: 1.1em;
            font-weight: bold;
            min-width: 100px;
        }
        .meter-labels {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 150px;
            font-size: 0.75em;
            color: #666;
            padding: 0 6px;
        }
        .meter-labels span {
            text-align: right;
            line-height: 1;
        }
        .meter-labels span:nth-child(1) { position: relative; top: -5px; }
        .meter-labels span:nth-child(2) { position: relative; top: -5px; }
        .meter-labels span:nth-child(3) { position: relative; top: 0px; }
        .meter-labels span:nth-child(4) { position: relative; top: 5px; }
        .meter-labels span:nth-child(5) { position: relative; top: 10px; }
        .meter-labels span:nth-child(6) { position: relative; top: 15px; }



        .ip-group {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        .ip-group input[type="text"] {
            width: 150px;
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
            font-size: 0.95em;
        }
        .ip-group button {
            padding: 6px 14px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
        }
        .bus-select-group {
            margin-top: 8px;
        }
        .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #999;
            vertical-align: middle;
        }

        .bus-select-group select {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
            font-size: 0.95em;
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>X32 Livestream Stabilizer Control</h1>

        <div class="grid-container">
            <div class="status-box">
                <h2>Current Status</h2>
                <div class="status-item">
                    <strong>Mixer IP:</strong>
                    <div class="ip-group">
                        <input type="text" id="mixer_ip_input" placeholder="192.168.1.1" value="192.168.150.10">
                        <button onclick="setMixerIp()">Set IP</button>
                    </div>
                </div>
                <div class="status-item">
                    <strong>Output:</strong>
                    <div class="bus-select-group">
                        <select id="bus_select" onchange="onBusSelectChange()">
                            <option value="" disabled selected>Connect to populate...</option>
                        </select>
                    </div>
                </div>
                <div class="status-item"><strong>Connection:</strong> <span id="connected">N/A</span></div>
                <div class="status-item"><strong>Overall Status:</strong> <span id="overall_status"><span id="status_dot" class="status-dot"></span> <span id="status_text">N/A</span></span></div>
                <div style="font-size:0.75em; color:#666; margin: 2px 0 4px 0;">
                    <span class="status-dot" style="background:#999;"></span> Stopped
                    &nbsp;<span class="status-dot" style="background:#FFC107;"></span> Connecting
                    &nbsp;<span class="status-dot" style="background:#4CAF50;"></span> Monitoring
                    &nbsp;<span class="status-dot" style="background:#2196F3;"></span> Silence
                    &nbsp;<span class="status-dot" style="background:#F44336;"></span> Error
                </div>
                <hr>
                <div class="level-meter-display">
                    <div class="meter-column">
                        <div class="meter-label">Input</div>
                        <div class="meter-container">
                            <div id="level_bar" class="level-bar"></div>
                        </div>
                    </div>
                    <div class="meter-column">
                        <div class="meter-label">Fader</div>
                        <div class="meter-container">
                            <div id="fader_bar" class="level-bar" style="background-color: #2196F3;"></div>
                        </div>
                    </div>
                    <div class="meter-labels">
                        <span>+6</span>
                        <span>0</span>
                        <span>-6</span>
                        <span>-12</span>
                        <span>-24</span>
                        <span>-48</span>
                    </div>
                    <div class="level-values">
                        <div class="level-value">
                            <strong>Input Level:</strong> <span id="current_level_numeric">N/A</span>
                        </div>
                        <div class="level-value">
                            <strong>Fader Position:</strong> <span id="current_fader">N/A</span>
                        </div>
                    </div>
                </div>
                <div style="font-size:0.8em; color:#666; margin-bottom:8px;">
                    <span style="color:#4CAF50;">&#9632;</span> Normal
                    &nbsp;<span style="color:orange;">&#9632;</span> Hot (above -6 dB)
                    &nbsp;<span style="color:red;">&#9632;</span> Clipping (0 dB+)
                </div>
                <div class="status-item"><strong>Target Level:</strong> <span id="target_level">N/A</span></div>
                <div style="margin-top:10px;">
                    <strong style="font-size:0.85em;">Level History (60s)</strong>
                    <canvas id="history_chart" width="400" height="180" style="width:100%;height:180px;background:#1a1a2e;border-radius:4px;margin-top:4px;"></canvas>
                </div>
            </div>

            <div class="control-box">
                <h2>Control Actions</h2>
                <div class="controls">
                    <button class="start" onclick="controlMonitor('/start_monitor')">Start Monitoring</button>
                    <button class="stop" onclick="controlMonitor('/stop_monitor')">Stop Monitoring</button>
                </div>
                <label style="display:flex;align-items:center;gap:6px;margin-bottom:10px;cursor:pointer;">
                    <input type="checkbox" id="auto_start_toggle" onchange="setAutoStart(this.checked)">
                    <span>Auto-start on boot</span>
                </label>

                <hr>

                <h2>Target Output Level</h2>
                <div class="input-group">
                    <label for="new_target_level">Desired Output (dB):</label>
                    <input type="number" step="0.5" id="new_target_level" value="-38.0">
                    <button onclick="setTargetLevel()">Set Target</button>
                </div>
                <p><strong>Current:</strong> <span id="target_level_current">N/A</span></p>
                <p><em>Fader auto-adjusts so output = input + fader hits this target.</em></p>

                <hr>

                <h2>Stabilizer Tuning</h2>
                <div class="input-group">
                    <label for="new_slew">Slew Rate (dB/cycle):</label>
                    <input type="number" step="0.5" min="0.5" max="10" id="new_slew" value="2.0">
                    <p style="margin:2px 0;color:#666;font-size:0.85em;">Max fader movement per 0.5s. Lower = smoother.</p>
                </div>
                <div class="input-group">
                    <label for="new_smoothing">Meter Smoothing (0.05 - 0.5):</label>
                    <input type="number" step="0.05" min="0.05" max="0.5" id="new_smoothing" value="0.15">
                    <p style="margin:2px 0;color:#666;font-size:0.85em;">Noise filter. Lower = smoother but slower to react.</p>
                </div>
                <div class="input-group">
                    <label for="new_threshold">Silence Threshold (dB):</label>
                    <input type="number" step="1" min="-90" max="-20" id="new_threshold" value="-60">
                    <p style="margin:2px 0;color:#666;font-size:0.85em;">Below this, fader freezes (silence/between tracks).</p>
                </div>
                <button onclick="setStabilizerTuning()">Apply Tuning</button>
                <p><strong>Current:</strong> Slew: <span id="slew_val">N/A</span> dB | Smooth: <span id="smooth_val">N/A</span> | Threshold: <span id="threshold_val">N/A</span> dB</p>


            </div>
        </div>
        
        <div id="message_area" class="message" style="display: none;"></div>
    </div>

    <script>
        function showMessage(msg, type) {
            const msgArea = document.getElementById('message_area');
            msgArea.textContent = msg;
            msgArea.className = `message ${type}`;
            msgArea.style.display = 'block';
            setTimeout(() => msgArea.style.display = 'none', 5000); // Hide after 5 seconds
        }

        const METER_HEIGHT = 150;
        const METER_MAX_DB = 6;
        const METER_MIN_DB = -60;

        function dbToHeight(db) {
            let n = (db - METER_MIN_DB) / (METER_MAX_DB - METER_MIN_DB);
            return Math.max(0, Math.min(1, n)) * METER_HEIGHT;
        }

        function updateSignalMeter(level_db) {
            const bar = document.getElementById('level_bar');
            bar.style.height = dbToHeight(level_db) + 'px';
            if (level_db >= 0) {
                bar.style.backgroundColor = 'red';
            } else if (level_db >= -6) {
                bar.style.backgroundColor = 'orange';
            } else {
                bar.style.backgroundColor = '#4CAF50';
            }
        }

        function updateFaderMeter(fader_db) {
            const bar = document.getElementById('fader_bar');
            bar.style.height = dbToHeight(fader_db) + 'px';
        }



        // Track connection state to auto-populate dropdown once
        let wasConnected = false;
        let outputListLoaded = false;

        async function fetchStatus() {
            try {
                const response = await fetch('/status');
                const data = await response.json();

                // Sync IP input only if user isn't editing it
                if (document.activeElement !== document.getElementById('mixer_ip_input')) {
                    document.getElementById('mixer_ip_input').value = data.mixer_ip;
                }

                document.getElementById('connected').textContent = data.connected ? 'Yes' : 'No';
                document.getElementById('status_text').textContent = data.status_message;
                const dotColors = {stopped:'#999', connecting:'#FFC107', reconnecting:'#FFC107', monitoring:'#4CAF50', silence:'#2196F3', error:'#F44336'};
                document.getElementById('status_dot').style.backgroundColor = dotColors[data.stabilizer_state] || '#999';

                const currentLevel = parseFloat(data.current_level_db);
                const currentFader = parseFloat(data.current_fader_db);
                const targetLevel = parseFloat(data.target_level_db);


                document.getElementById('current_level_numeric').textContent = isNaN(currentLevel) ? 'N/A' : `${currentLevel.toFixed(2)} dB`;
                document.getElementById('current_fader').textContent = isNaN(currentFader) ? 'N/A' : `${currentFader.toFixed(2)} dB`;
                document.getElementById('target_level').textContent = data.target_level_db;
                document.getElementById('target_level_current').textContent = data.target_level_db;

                // Sync auto-start checkbox
                const autoStartCb = document.getElementById('auto_start_toggle');
                if (document.activeElement !== autoStartCb) {
                    autoStartCb.checked = data.auto_start;
                }

                document.getElementById('slew_val').textContent = data.slew_rate;
                document.getElementById('smooth_val').textContent = data.smoothing;
                document.getElementById('threshold_val').textContent = data.silence_threshold;

                if (!isNaN(currentLevel)) {
                    updateSignalMeter(currentLevel);
                }
                if (!isNaN(currentFader)) {
                    updateFaderMeter(currentFader);
                }

                // Auto-populate output dropdown when first connected
                if (data.connected && !wasConnected) {
                    outputListLoaded = false;
                }
                if (data.connected && !outputListLoaded) {
                    await fetchOutputList(data.livestream_bus);
                }
                if (!data.connected) {
                    outputListLoaded = false;
                }
                wasConnected = data.connected;

            } catch (error) {
                console.error('Error fetching status:', error);
                showMessage('Failed to fetch status: ' + error.message, 'error');
            }
        }

        async function controlMonitor(endpoint) {
            try {
                const response = await fetch(endpoint, { method: 'POST' });
                const data = await response.json();
                if (response.ok) {
                    showMessage(data.message, 'success');
                } else {
                    showMessage('Error: ' + (data.error || data.message), 'error');
                }
                fetchStatus(); // Update status after action
            } catch (error) {
                console.error('Error controlling monitor:', error);
                showMessage('Failed to send command: ' + error.message, 'error');
            }
        }

        async function setTargetLevel() {
            const newTarget = document.getElementById('new_target_level').value;
            try {
                const response = await fetch('/set_target_level', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 'target_level_db': parseFloat(newTarget) })
                });
                const data = await response.json();
                if (response.ok) {
                    showMessage(data.message, 'success');
                } else {
                    showMessage('Error: ' + (data.error || data.message), 'error');
                }
                fetchStatus();
            } catch (error) {
                console.error('Error setting target level:', error);
                showMessage('Failed to set target level: ' + error.message, 'error');
            }
        }

        async function setStabilizerTuning() {
            const slew = parseFloat(document.getElementById('new_slew').value);
            const smoothing = parseFloat(document.getElementById('new_smoothing').value);
            const threshold = parseFloat(document.getElementById('new_threshold').value);
            try {
                const response = await fetch('/set_tuning', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ slew_rate: slew, smoothing: smoothing, silence_threshold: threshold })
                });
                const data = await response.json();
                if (response.ok) {
                    showMessage(data.message, 'success');
                } else {
                    showMessage('Error: ' + (data.error || data.message), 'error');
                }
                fetchStatus();
            } catch (error) {
                console.error('Error setting tuning:', error);
                showMessage('Failed to set tuning: ' + error.message, 'error');
            }
        }

        async function setMixerIp() {
            const ip = document.getElementById('mixer_ip_input').value.trim();
            try {
                const response = await fetch('/set_mixer_ip', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ip: ip })
                });
                const data = await response.json();
                if (response.ok) {
                    showMessage(data.message, 'success');
                } else {
                    showMessage('Error: ' + (data.error || data.message), 'error');
                }
                fetchStatus();
            } catch (error) {
                showMessage('Failed to set IP: ' + error.message, 'error');
            }
        }

        async function fetchOutputList(currentBusId) {
            try {
                const response = await fetch('/output_list');
                const data = await response.json();
                if (!response.ok) return;

                const select = document.getElementById('bus_select');
                select.innerHTML = '';
                data.outputs.forEach(output => {
                    const opt = document.createElement('option');
                    opt.value = output.id;
                    // Format: "Matrix 1 — Video M1" or "Bus 3 — FOH" or "Main ST"
                    if (output.type === 'Main') {
                        opt.textContent = output.name;
                    } else {
                        const defaultName = output.type === 'Bus' ? `Bus ${output.id}` : `Matrix ${output.id.toString().replace('mtx', '')}`;
                        if (output.name !== defaultName) {
                            opt.textContent = `${defaultName} — ${output.name}`;
                        } else {
                            opt.textContent = defaultName;
                        }
                    }
                    // Select the currently active bus
                    if (String(output.id) === String(currentBusId)) {
                        opt.selected = true;
                    }
                    select.appendChild(opt);
                });
                outputListLoaded = true;
            } catch (error) {
                console.error('Error fetching output list:', error);
            }
        }

        async function setAutoStart(enabled) {
            try {
                const response = await fetch('/set_auto_start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled: enabled })
                });
                const data = await response.json();
                if (response.ok) {
                    showMessage(data.message, 'success');
                } else {
                    showMessage('Error: ' + (data.error || data.message), 'error');
                }
            } catch (error) {
                showMessage('Failed to set auto-start: ' + error.message, 'error');
            }
        }

        async function onBusSelectChange() {
            const select = document.getElementById('bus_select');
            let busId = select.value;
            // Convert to int if numeric (bus 1-16)
            if (/^\d+$/.test(busId)) busId = parseInt(busId);
            try {
                const response = await fetch('/set_livestream_bus', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ bus_id: busId })
                });
                const data = await response.json();
                if (response.ok) {
                    showMessage(data.message, 'success');
                } else {
                    showMessage('Error: ' + (data.error || data.message), 'error');
                }
                fetchStatus();
            } catch (error) {
                showMessage('Failed to select output: ' + error.message, 'error');
            }
        }


        // Fast meter polling (5 Hz) for smooth meter animation
        async function fetchMeter() {
            try {
                const response = await fetch('/meter');
                const data = await response.json();
                const level = data.level_db;
                const fader = data.fader_db;
                if (level !== null && level !== undefined) {
                    document.getElementById('current_level_numeric').textContent = `${level.toFixed(2)} dB`;
                    updateSignalMeter(level);
                } else {
                    document.getElementById('current_level_numeric').textContent = 'Waiting...';
                }
                if (fader !== null && fader !== undefined) {
                    document.getElementById('current_fader').textContent = `${fader.toFixed(2)} dB`;
                    updateFaderMeter(fader);
                }
            } catch (e) {
                // Silently ignore - /status poll will show errors
            }
        }

        // History chart drawing
        let historyData = [];
        async function fetchHistory() {
            try {
                const response = await fetch('/history');
                historyData = await response.json();
                drawHistoryChart();
            } catch (e) {}
        }

        function drawHistoryChart() {
            const canvas = document.getElementById('history_chart');
            const ctx = canvas.getContext('2d');
            const W = canvas.width, H = canvas.height;
            const PAD_L = 40, PAD_R = 10, PAD_T = 10, PAD_B = 22;
            const plotW = W - PAD_L - PAD_R, plotH = H - PAD_T - PAD_B;
            const DB_MIN = -60, DB_MAX = 6;

            ctx.clearRect(0, 0, W, H);

            // Background
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, W, H);

            // Y-axis labels and grid
            ctx.font = '10px Arial';
            ctx.textAlign = 'right';
            const yTicks = [6, 0, -6, -12, -24, -48, -60];
            for (const db of yTicks) {
                const y = PAD_T + plotH * (1 - (db - DB_MIN) / (DB_MAX - DB_MIN));
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.beginPath(); ctx.moveTo(PAD_L, y); ctx.lineTo(PAD_L + plotW, y); ctx.stroke();
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.fillText(db + '', PAD_L - 4, y + 3);
            }

            // Time labels on bottom (always visible)
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.textAlign = 'center';
            ctx.font = '9px Arial';
            for (let s = 0; s <= 60; s += 15) {
                const x = PAD_L + plotW * (s / 60);
                ctx.fillText(s === 0 ? '-60s' : s === 60 ? 'now' : `-${60 - s}s`, x, H - 4);
            }

            // Legend (always visible)
            ctx.font = '9px Arial';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#4CAF50'; ctx.fillText('Input', PAD_L + 4, PAD_T + 12);
            ctx.fillStyle = '#2196F3'; ctx.fillText('Fader', PAD_L + 40, PAD_T + 12);
            ctx.fillStyle = 'rgba(255,255,0,0.6)'; ctx.fillText('Target', PAD_L + 76, PAD_T + 12);

            if (historyData.length < 2) {
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.textAlign = 'center';
                ctx.font = '13px Arial';
                ctx.fillText('Start monitoring to see history', W / 2, H / 2 + 5);
                return;
            }

            const now = historyData[historyData.length - 1].t;
            const tMin = now - 60;

            // Target level dashed line
            const statusTargetEl = document.getElementById('target_level');
            const targetDb = parseFloat(statusTargetEl.textContent);
            if (!isNaN(targetDb) && targetDb >= DB_MIN && targetDb <= DB_MAX) {
                const ty = PAD_T + plotH * (1 - (targetDb - DB_MIN) / (DB_MAX - DB_MIN));
                ctx.setLineDash([4, 4]);
                ctx.strokeStyle = 'rgba(255,255,0,0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(PAD_L, ty); ctx.lineTo(PAD_L + plotW, ty); ctx.stroke();
                ctx.setLineDash([]);
            }

            function drawLine(key, color) {
                ctx.strokeStyle = color;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                let started = false;
                for (const pt of historyData) {
                    if (pt.t < tMin) continue;
                    const x = PAD_L + plotW * ((pt.t - tMin) / 60);
                    const db = Math.max(DB_MIN, Math.min(DB_MAX, pt[key]));
                    const y = PAD_T + plotH * (1 - (db - DB_MIN) / (DB_MAX - DB_MIN));
                    if (!started) { ctx.moveTo(x, y); started = true; }
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            drawLine('level', '#4CAF50');
            drawLine('fader', '#2196F3');
        }

        // Fast meter poll at 200ms (5 Hz)
        setInterval(fetchMeter, 200);
        // Full status poll at 2s (PID values, connection, etc.)
        setInterval(fetchStatus, 2000);
        // History chart poll at 1s
        setInterval(fetchHistory, 1000);
        // Initial fetch
        fetchStatus();
        fetchHistory();
    </script>
</body>
</html>
